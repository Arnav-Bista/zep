// ENTIRE FILE IS CUSTOM
package postgres

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"sync"

	"github.com/getzep/zep/pkg/models"
	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

func NewFactDAO(db *bun.DB, appState *models.AppState, sessionID string) (*FactDAO, error) {
	if sessionID == "" {
		return nil, errors.New("sessionID cannot be empty")
	}
	return &FactDAO{
		db:        db,
		appState:  appState,
		sessionID: sessionID,
	}, nil
}

type FactDAO struct {
	db        *bun.DB
	appState  *models.AppState
	sessionID string
}

// Create create a new fact for a session. Does not create a session if it does not exist.
func (dao *FactDAO) Create(
	ctx context.Context,
	fact *models.Fact,
) (*models.Fact, error) {
	pgFact := FactStoreSchema{
		UUID:          fact.UUID,
		SessionID:     dao.sessionID,
		Content:       fact.Content,
		FactPointUUID: fact.FactPointUUID,
		TokenCount:    fact.TokenCount,
		Metadata:      fact.Metadata,
	}

	// Insert
	_, err := dao.db.NewInsert().
		Model(&pgFact).
		Returning("*").
		Exec(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to create message: %w", err)
	}

	return &models.Fact{
		UUID:       pgFact.UUID,
		CreatedAt:  pgFact.CreatedAt,
		UpdatedAt:  pgFact.UpdatedAt,
		Content:    pgFact.Content,
		TokenCount: pgFact.TokenCount,
		Metadata:   pgFact.Metadata,
	}, nil
}

func (dao *FactDAO) CreateMany(
	ctx context.Context,
	facts []models.Fact,
) ([]models.Fact, error) {
	if len(facts) == 0 {
		return nil, nil
	}	

	// Get latest summary uuid
	summaryDAO, err := NewSummaryDAO(dao.db, dao.appState, dao.sessionID)
	if err != nil {
		return nil, fmt.Errorf("failed to create summaryDAO: %w", err)
	}
	
	// Get the most recently added summary uuid
	var summaryUUID uuid.UUID
	e := summaryDAO.db.NewSelect(). 
		Model(&SummaryStoreSchema{}). 
		Where("session_id = ?", dao.sessionID).
		Order("created_at DESC"). 
		Limit(1). 
		Column("uuid").
		Scan(ctx, &summaryUUID)
	if e != nil {
		return nil, fmt.Errorf("failed to get summary uuid: %w", e)
	}


	pgFacts := make([]FactStoreSchema, len(facts))
	for i, fact := range facts {
		pgFacts[i] = FactStoreSchema{
			UUID:          fact.UUID,
			SessionID:     dao.sessionID,
			Content:       fact.Content,
			TokenCount:    fact.TokenCount,
			Metadata:      fact.Metadata,
			FactPointUUID: summaryUUID,
		}
	}

	_, err = dao.db.NewInsert().
		Model(&pgFacts).
		Returning("*").
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create facts: %w", err)
	}

	facts = factsFromStoreSchema(pgFacts)

	return facts, nil
}

func (dao *FactDAO) Update(
	ctx context.Context,
	fact *models.Fact,
) (*models.Fact, error) {
	if fact.UUID == uuid.Nil {
		return nil, errors.New("fact UUID cannot be empty")
	}

	tx, err := dao.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer rollbackOnError(tx)

	metadata, err := mergeMetadata(
		ctx,
		tx,
		"uuid",
		fact.UUID.String(),
		"fact",
		fact.Metadata,
		true,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to update fact metadata: %w", err)
	}

	pgFact := FactStoreSchema{
		UUID:       fact.UUID,
		Content:    fact.Content,
		TokenCount: fact.TokenCount,
		Metadata:   metadata,
	}

	columns := []string{"content", "metadata", "token_count"}
	_, err = tx.NewUpdate().
		Model(&pgFact).
		Column(columns...).
		Where("uuid = ?", fact.UUID).
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to update fact: %w", err)
	}

	err = tx.Commit()
	if err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return fact, nil

}

// Get by UUID
func (dao *FactDAO) Get(
	ctx context.Context,
	factUUID uuid.UUID,
) (*models.Fact, error) {
	var facts FactStoreSchema
	err := dao.db.NewSelect().
		Model(&facts).
		Where("session_id = ?", dao.sessionID).
		Where("uuid = ?", factUUID).
		Scan(ctx)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, models.NewNotFoundError(fmt.Sprintf("fact with UUID %s not found", factUUID))
		}
		return nil, fmt.Errorf("failed to get fact: %w", err)
	}

	return &models.Fact{
		UUID:       facts.UUID,
		CreatedAt:  facts.CreatedAt,
		UpdatedAt:  facts.UpdatedAt,
		Content:    facts.Content,
		TokenCount: facts.TokenCount,
		Metadata:   facts.Metadata,
	}, nil
}

// Get all for this session
func (dao *FactDAO) GetAll(
	ctx context.Context,
	factPointUUID uuid.UUID,
) ([]models.Fact, error) {
	var facts []FactStoreSchema
	// Print the table column names
	log.Debugf("********************************* ==================== \nColumns: %v", dao.db.NewSelect().Model((*FactStoreSchema)(nil)).Column());
	// Print all Summary UUIDS  from the summary table
	// Print the entire summary table
	log.Debugf("*** SUMMARYS : %s", dao.db.NewSelect().Model((*SummaryStoreSchema)(nil)).Scan(ctx));
	// log.Debugf("*** SUMMARY UUIDS: %s", dao.db.NewSelect().Model((*SummaryStoreSchema)(nil)).Column("uuid").Scan(ctx));
	log.Debugf("*** FACTS : %s", dao.db.NewSelect().Model(&facts).Scan(ctx));

	err := dao.db.NewSelect().
		Model(&facts).
		Where("session_id = ?", dao.sessionID).
		Where("fact_point_uuid = ?", factPointUUID).
		Scan(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get facts: %w", err)
	}

	return factsFromStoreSchema(facts), nil
}

// Delete All
func (dao *FactDAO) DeleteAll(
	ctx context.Context,
) error {

	tx, err := dao.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	_, err = tx.NewDelete().
		Model((*FactStoreSchema)(nil)).
		Where("session_id = ?", dao.sessionID).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to delete facts: %w", err)
	}

	err = tx.Commit()
	if err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

func factsFromStoreSchema(facts []FactStoreSchema) []models.Fact {
	factList := make([]models.Fact, len(facts))
	for i, fact := range facts {
		factList[i] = models.Fact{
			UUID:       fact.UUID,
			CreatedAt:  fact.CreatedAt,
			UpdatedAt:  fact.UpdatedAt,
			Content:    fact.Content,
			TokenCount: fact.TokenCount,
			Metadata:   fact.Metadata,
		}
	}
	return factList
}

func (pms *PostgresMemoryStore) GetFactList(
	ctx context.Context,
	sessionID string,
	pageNumber int,
	pageSize int,
) (*models.FactListResponse, error) {
	factDAO, err := NewFactDAO(pms.Client, pms.appState, sessionID)
	if err != nil {
		return nil, err
	}

	return factDAO.GetListBySession(ctx, pageNumber, pageSize)
}

func (dao *FactDAO) GetListBySession(
	ctx context.Context,
	currentPage int,
	pageSize int,
) (*models.FactListResponse, error) {

	var wg sync.WaitGroup
	var countErr error
	var count int

	wg.Add(1)
	go func() {
		defer wg.Done()

		count, countErr = dao.db.NewSelect().
			Model(&FactStoreSchema{}).
			Where("session_id = ?", dao.sessionID).
			Count(ctx)
	}()

	var facts []FactStoreSchema
	err := dao.db.NewSelect().
		Model(&facts).
		Where("session_id = ?", dao.sessionID).
		OrderExpr("created_at ASC").
		Offset((currentPage - 1) * pageSize).
		Limit(pageSize).
		Scan(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get facts: %w", err)
	}
	if len(facts) == 0 {
		return &models.FactListResponse{
			Facts:      []models.Fact{},
			TotalCount: 0,
			RowCount:   0,
		}, nil
	}

	factList := make([]models.Fact, len(facts))
	for i, fact := range facts {
		factList[i] = models.Fact{
			UUID:       fact.UUID,
			CreatedAt:  fact.CreatedAt,
			UpdatedAt:  fact.UpdatedAt,
			Content:    fact.Content,
			TokenCount: fact.TokenCount,
			Metadata:   fact.Metadata,
		}
	}

	wg.Wait()
	if countErr != nil {
		return nil, fmt.Errorf("failed to get fact count: %w", countErr)
	}

	return &models.FactListResponse{
		Facts:      factList,
		TotalCount: count,
		RowCount:   len(facts),
	}, nil
}
